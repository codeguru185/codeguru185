from sqlalchemy import create_engine, MetaData
from sqlalchemy.orm import sessionmaker
from faker import Faker
from random import randint

# Set up the database connection and session
engine = create_engine("postgresql+psycopg2://user:password@host/dbname")
Session = sessionmaker(bind=engine)
session = Session()
metadata = MetaData(bind=engine)
metadata.reflect()

fake = Faker()

# Define the number of rows you want to insert per table
ROWS_PER_TABLE = {
    'table1': 100,
    'table2': 50,
    'table3': 150  # Add more tables and row counts as needed
}

# Insert data with respect to foreign key dependencies
for table in metadata.sorted_tables:
    # Skip tables if not in the ROWS_PER_TABLE dictionary
    if table.name not in ROWS_PER_TABLE:
        continue

    # Number of rows to insert for the current table
    num_rows = ROWS_PER_TABLE[table.name]

    print(f"Inserting {num_rows} rows into {table.name}...")

    # Generate and insert the rows
    for _ in range(num_rows):
        row_data = {}
        
        for column in table.columns:
            if column.foreign_keys:
                # If foreign key, get a random existing foreign key ID from the referenced table
                fk_column = list(column.foreign_keys)[0].column
                fk_table = fk_column.table
                fk_id = session.query(fk_column).order_by(fk_column).limit(1).offset(randint(0, num_rows-1)).scalar()
                row_data[column.name] = fk_id
            elif column.type.python_type == str:
                row_data[column.name] = fake.word() if not column.primary_key else None  # Avoid primary key conflicts
            elif column.type.python_type == int:
                row_data[column.name] = randint(1, 100)
            elif column.type.python_type == float:
                row_data[column.name] = fake.pyfloat(left_digits=2, right_digits=2, positive=True)
            elif column.type.python_type == bool:
                row_data[column.name] = fake.boolean()
            # Add other type cases as necessary

        # Insert the row data into the table, skip if primary key data is missing
        if all(row_data[key] is not None for key in row_data.keys() if key in table.primary_key.columns):
            session.execute(table.insert().values(**row_data))

    # Commit after each table's insertions to keep changes isolated
    session.commit()

print("Data insertion complete!")
